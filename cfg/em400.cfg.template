computer {
	# Set CPU and memory backend:
	# "false" - use emulated CPU and memory (default)
	# "true" - use FPGA implementation of CPU and memory
	fpga = false

	# real CPU and I/O emulation speed:
	# "false" - run as fast as possible (default)
	# "true" - try to emulate actual instructions, memory and I/O timings
	speed_real = false

	# Internal clock interrupt period (in miliseconds)
	# allowed values: 2-100 (default is 10)
	# Note: cycle lengths available for real hardware were:
	# 2, 4, 8, 10, 20, 40, 80 (10 was the default)
	clock_period = 10

	# Start clock at power on.
	# allowed values: "true" (default), "false"
	clock_start = true

	# MERA-400 cpu stops when operating system tries to access unconfigured
	# memory segment, but this can be changed to work as for user programs:
	# only interrupt is fired. Allowed values: "true" (default), "false"
	cpu_stop_on_nomem = true

	# 'IN' and 'OU' instructions can be either illegal or legal in user programs
	# allowed values: "true" (default), "false"
	cpu_user_io_illegal = true

	# AWP (hardware 48-bit floating point and 32-bit fixed point arithmetic) is optional
	# allowed values: "true" (default), "false"
	cpu_awp = true

	# Enable CPU modification (17-bit byte addressing, additional instructions,
	# additional software interrupt, int 5/11 swap, broader interrupt mask
	# for I/O interrupts)
	# allowed values: "true", "false" (default)
	cpu_mod = false

	# Memory is organized into 16 physical modules. Each module can be
	# either elwro or mega. Elwro modules are 32kword big (8 pages),
	# mega modules are 64kword in size (16 pages).
	# Module 0 always has to be populated with elwro memory.
	# Elwro modules are populated starting from 0 up, mega modules
	# from 15 down. Module 0 may be overlapped by mega module

	# allowed values: 1-16 (default: 1)
	mem_elwro = 1

	# allowed values: 0-16 (default: 0)
	mem_mega = 0

	# 4kword segments hardwired for OS memory block (taken from module 0)
	# allowed values: 1 or 2 (default: 2)
	mem_os_segments = 2

	# Name of image file containing MEGA PROM memory.
	# File has to be 8KB in size (1 full segment, 4kwords).
	# (default: none)
	#mem_mega_prom = "mega_prom.img"

	# Enable or disable boot from MEGA PROM memory.
	# Works only when mem_mega_prom is specified.
	# allowed values: "true, "false" (default)
	mem_mega_boot = false
}

fpga {
	# Device to use for communication with the FPGA backend. Default: /dev/ttyUSB0
	device = "/dev/ttyUSB1"
	# FPGA link speed (in baud). Default: 1000000
	speed = 1000000
}

log {
	# Enable or disable logging.
	# Not recommended for daily usage due to considerable performance requirements.
	# Allowed values: "true", "false" (default)
	enabled = false

	# Name of the log file (default: em400.log)
	file = "em400.log"

	# Select which components write logs for.
	#
	# "<component>,..."
	#
	# Available components are:
	#   em4h - emulator
	#   reg, mem, cpu, op, int - registers, memory, cpu cycle, instructions, interrupts
	#   io, mx, px, cchr, cmem - general I/O, MULTIX, PLIX, character and memory channel
	#   term, 9425, wnch, flop, pnch, pnrd, tape - terminal, mera 9425, winchester, floppy, tape puncher and reader, magnetic tape
	#   crk5 - CROOK-5
	#   em4h - emulator, general
	#   ectl - emulator, remote control
	#   fpga - emulation-fpga I/O bridge
	#   all - special "component" to enable or disable all components
	#
	# default: none
	components = "em4h,cpu"

	# Use line buffered log output. If disabled, log is fully buffered.
	# Default is true.
	line_buffered = true
}

#channel 0 = mem {
#	unit 0 = mera9425: /home/amo/disk1.img, /home/amo/disk2.img
#}

#channel 1 = char {
#	unit 0 = term_cons
#	unit 1 = term_tcp: 23400
#	unit 2 = term_serial: /dev/ttyS0, 9600, 8, N, 1
#}
#

channel 1 = multix {
#	unit 0 = puncher
#	unit 1 = puncher
#	unit 2 = puncher
#	unit 3 = punchreader
#	unit 4 = terminal
#	unit 5 = terminal
#	unit 6 = terminal
#	unit 7 = terminal
#	unit 8 = terminal
#	unit 9 = terminal
#	unit 10 = terminal
#	unit 11 = terminal
#	unit 12 = terminal
#	unit 13 = terminal
#	unit 14 = terminal
#	unit 15 = terminal
#	unit 20 = floppy: floppy.e4i
#	unit 21 = floppy: floppy.e4i
#	unit 28 = winchester: winchester_amo.e4i
}

#channel 15 = char {
#	unit 4 = term_cons
#}
